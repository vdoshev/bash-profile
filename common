#!/usr/bin/env bash
# shellcheck disable=SC2139 # expands when defined, not when used

# Print ${PATH} in user friendly maner
alias PATH='(echo "${PATH}" | tr ":" "\n")'

alias l='ls -lha'
alias env='env | sort'
alias cls=clear

# Find all declared variables with names starting with ...
alias declared='declare -p | grep '

# Find all files except the contents of system folders
alias find-f="find . -type f -not -path './.*/*' | sort"
alias find-tree="find . -not -path './.*/*' | sort | sed 's/[^/]*\//|  /g; ;s/| *\([^| ]\)/+-- \1/'"

# Trim spaces, new lines, comments, empty lines, etc.
alias trim-space='sed -e '\''s/^[ \t]*//; s/[ \t]*$//;'\'''
alias trim-nl='tr -d '\''\n'\'''
alias trim-comments='sed '\''/^#.*$/d'\'''
alias trim-empty='sed '\''/^$/d'\'''

alias cd-bash='cd '"${BASH_PROFILE_DIR}"

alias encode-secret="${BASH_PROFILE_DIR}"'/sh/secret.sh'
alias decode-secret="${BASH_PROFILE_DIR}"'/sh/secret.sh -d'

if command -v cygpath &> /dev/null; then
  # Convert Unix format paths to Windows path, with regular slashes.
  function winpath() {
    cygpath "${1}" --absolute --mixed
  }

  # Convert Windows format paths (with any type of slashes) to Unix path.
  function nixpath() {
    cygpath "${1}" --absolute --unix   
  }
elif [[ -n ${DRIVES_PATH} ]]; then
  # Convert Unix format paths to Windows path, with regular slashes.
  function winpath() {
    local nix_path=$1
    local sed_script="s|^${DRIVES_PATH/%\//}/\([a-zA-Z]\)/|\1:/|"
    local ret
    ret=$(echo "${nix_path}" | sed -e "${sed_script}")
    if [[ ${ret:1:1} = ':' ]]; then
      echo "${ret^}"
    else
      echo "${ret}"
    fi
  }

  # Convert Windows format paths (with any type of slashes) to Unix path.
  function nixpath() {
    local win_path=$1
    local sed_script="s|\\\\|/|g; s|^\([a-zA-Z]\):|${DRIVES_PATH/%\//}/\1|"
    echo "${win_path,}" | sed -e "${sed_script}"
  }
fi

# Make directory (or directories) and change the shell working directory
function mkcd() {
  mkdir -p "$1" && cd "$1" || return $?
}

# Go to the first directory where the command executable is foundwhich
function cdto() {
  local cmd=${1:?command}
  local -a paths
  IFS='' read -r -a paths < <(which "${cmd}" 2> /dev/null)
  if [[ ${#paths[@]} -gt 0 ]]; then
    cd "$(dirname "${paths[0]}")" || return 2
    return 0
  fi
  return 1
}

# Swap two files
function swap_files() {
  local tmp=tmp.$$
  mv "$1" $tmp \
    && mv "$2" "$1" \
    && mv $tmp "$2"
}

# Make a backup copy of a file
function backup_file() {
  cp -v "${1}" "${1}-$(now f)"
}

# Current date/time in different formats
function now() {
  case ${1:-d} in
    z) date '+%Y-%m-%dT%H:%M:%SZ' ;; # 2023-10-13T11:06:50Z
    d) date '+%Y-%m-%d %H:%M:%S'  ;; # 2023-10-13 11:09:53
    f) date '+%Y%m%d-%H%M%S'      ;; # 20231013-111012
    *) backup_file "${1}"         ;;
  esac
}

# Rename files matching "*${1}*" to "*${2}*"
function rename_all() {
  local match=$1 replace=$2
  for filename in *"${match}"*; do
    mv -v "${filename}" "${filename/${match}/${replace}}"
  done
}

# Print META-INF/MANIFEST.MF of a jar file
function jar_info() {
  local dir
  for jar in "$@"; do
    dir=$(mktemp -d)
    unzip -q "${jar}" -d "${dir}" META-INF/MANIFEST.MF
    mv "${dir}/META-INF/MANIFEST.MF" "${jar}-info"
    rm -rf "${dir}"
  done
}
